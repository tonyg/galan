/* Generated by GOB (v2.0.12) on Tue Feb 10 02:11:45 2009
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 12

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "galan-comptree-model.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 22 "galan-comptree-model.gob"

//static GtkTargetEntry targette = { "galan/CompAction", 0, 234 };

#line 29 "galan-comptree-model.c"
/* self casting macros */
#define SELF(x) GALAN_COMPTREE_MODEL(x)
#define SELF_CONST(x) GALAN_COMPTREE_MODEL_CONST(x)
#define IS_SELF(x) GALAN_IS_COMPTREE_MODEL(x)
#define TYPE_SELF GALAN_TYPE_COMPTREE_MODEL
#define SELF_CLASS(x) GALAN_COMPTREE_MODEL_CLASS(x)

#define SELF_GET_CLASS(x) GALAN_COMPTREE_MODEL_GET_CLASS(x)

/* self typedefs */
typedef GalanCompTreeModel Self;
typedef GalanCompTreeModelClass SelfClass;

/* here are local prototypes */
static void galan_comptree_model_class_init (GalanCompTreeModelClass * c) G_GNUC_UNUSED;
static void galan_comptree_model_init (GalanCompTreeModel * self) G_GNUC_UNUSED;
static gboolean galan_comptree_model_drag_data_delete (GtkTreeDragSource * self, GtkTreePath * path) G_GNUC_UNUSED;
static gboolean galan_comptree_model_drag_data_get (GtkTreeDragSource * self, GtkTreePath * path, GtkSelectionData * data) G_GNUC_UNUSED;
static gboolean galan_comptree_model_drag_data_received (GtkTreeDragDest * self, GtkTreePath * path, GtkSelectionData * data) G_GNUC_UNUSED;
static gboolean galan_comptree_model_row_drop_possible (GtkTreeDragDest * self, GtkTreePath * path, GtkSelectionData * data) G_GNUC_UNUSED;

/* pointer to the class of our parent */
static GtkTreeStoreClass *parent_class = NULL;

/* Short form macros */
#define self_lookup galan_comptree_model_lookup
#define self_drag_data_delete galan_comptree_model_drag_data_delete
#define self_drag_data_get galan_comptree_model_drag_data_get
#define self_drag_data_received galan_comptree_model_drag_data_received
#define self_row_drop_possible galan_comptree_model_row_drop_possible


static void
___Gtk_Tree_Drag_Source_init (GtkTreeDragSourceIface *iface)
{
#line 99 "galan-comptree-model.gob"
	iface->drag_data_delete = self_drag_data_delete;
#line 111 "galan-comptree-model.gob"
	iface->drag_data_get = self_drag_data_get;
#line 69 "galan-comptree-model.c"
}


static void
___Gtk_Tree_Drag_Dest_init (GtkTreeDragDestIface *iface)
{
#line 138 "galan-comptree-model.gob"
	iface->drag_data_received = self_drag_data_received;
#line 157 "galan-comptree-model.gob"
	iface->row_drop_possible = self_row_drop_possible;
#line 80 "galan-comptree-model.c"
}

GType
galan_comptree_model_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (GalanCompTreeModelClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) galan_comptree_model_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (GalanCompTreeModel),
			0 /* n_preallocs */,
			(GInstanceInitFunc) galan_comptree_model_init,
			NULL
		};

		static const GInterfaceInfo Gtk_Tree_Drag_Source_info = {
			(GInterfaceInitFunc) ___Gtk_Tree_Drag_Source_init,
			NULL,
			NULL
		};

		static const GInterfaceInfo Gtk_Tree_Drag_Dest_info = {
			(GInterfaceInitFunc) ___Gtk_Tree_Drag_Dest_init,
			NULL,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_TREE_STORE, "GalanCompTreeModel", &info, (GTypeFlags)0);
		g_type_add_interface_static (type,
			GTK_TYPE_TREE_DRAG_SOURCE,
			&Gtk_Tree_Drag_Source_info);
		g_type_add_interface_static (type,
			GTK_TYPE_TREE_DRAG_DEST,
			&Gtk_Tree_Drag_Dest_info);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((GalanCompTreeModel *)g_object_new(galan_comptree_model_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static GalanCompTreeModel * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static GalanCompTreeModel *
GET_NEW_VARG (const char *first, ...)
{
	GalanCompTreeModel *ret;
	va_list ap;
	va_start (ap, first);
	ret = (GalanCompTreeModel *)g_object_new_valist (galan_comptree_model_get_type (), first, ap);
	va_end (ap);
	return ret;
}

static void 
galan_comptree_model_class_init (GalanCompTreeModelClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::class_init"

	parent_class = g_type_class_ref (GTK_TYPE_TREE_STORE);

}
#undef __GOB_FUNCTION__
#line 31 "galan-comptree-model.gob"
static void 
galan_comptree_model_init (GalanCompTreeModel * self G_GNUC_UNUSED)
#line 155 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::init"
 {
#line 31 "galan-comptree-model.gob"


		GType mytypes[] = { G_TYPE_STRING, G_TYPE_BOOLEAN, GALAN_TYPE_COMPACTION };
		gtk_tree_store_set_column_types( GTK_TREE_STORE( self ), 3, mytypes );
	
#line 165 "galan-comptree-model.c"
 }
}
#undef __GOB_FUNCTION__



#line 37 "galan-comptree-model.gob"
gboolean 
galan_comptree_model_lookup (GalanCompTreeModel * self, char * path, GtkTreeIter * iter, gboolean create)
#line 175 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::lookup"
#line 37 "galan-comptree-model.gob"
	g_return_val_if_fail (self != NULL, (gboolean )0);
#line 37 "galan-comptree-model.gob"
	g_return_val_if_fail (GALAN_IS_COMPTREE_MODEL (self), (gboolean )0);
#line 182 "galan-comptree-model.c"
{
#line 37 "galan-comptree-model.gob"
	

		GtkTreeModel *model = GTK_TREE_MODEL( self );

		gchar **splitpath = g_strsplit( path, "/", -1 );
		int i=0;
		if( ! gtk_tree_model_get_iter_first( model, iter ) ) {

			if( create ) {
				gtk_tree_store_append( GTK_TREE_STORE(self), iter, NULL );
				gtk_tree_store_set( GTK_TREE_STORE(self), iter, 0, splitpath[i], 1, FALSE, -1 );
			} else {
				g_strfreev( splitpath );
				return FALSE;
			}
		}
		while( splitpath[i] ) {
			int found = 0;
			GtkTreeIter olditer;
			do {
				char *name;
				gtk_tree_model_get( model, iter, 0, &name, -1 );
				if( !strcmp( name, splitpath[i] ) ) {
					found = 1;
				}
				g_free(name);
				olditer = *iter;
			} while( (!found) && gtk_tree_model_iter_next( model, iter ) );
			if( !found ) {
				if( create ) {
					gtk_tree_store_insert_after( GTK_TREE_STORE(self), iter, NULL, &olditer );
					gtk_tree_store_set( GTK_TREE_STORE(self), iter, 0, splitpath[i], 1, FALSE, -1 );
				} else {
					g_strfreev( splitpath );
					return FALSE;
				}
			}
			i++;
			if( splitpath[i] == NULL ) {
				g_strfreev( splitpath );
				return TRUE;
			}

			olditer = *iter;
			if( !gtk_tree_model_iter_children( model, iter, &olditer ) ) {
				if( create ) {
					gtk_tree_store_append( GTK_TREE_STORE(self), iter, &olditer );
					gtk_tree_store_set( GTK_TREE_STORE(self), iter, 0, splitpath[i], 1, FALSE, -1 );
				} else {
					g_strfreev( splitpath );
					return FALSE;
				}
			}

		}

		g_strfreev( splitpath );
		return FALSE;

	}}
#line 245 "galan-comptree-model.c"
#undef __GOB_FUNCTION__

#line 99 "galan-comptree-model.gob"
static gboolean 
galan_comptree_model_drag_data_delete (GtkTreeDragSource * self, GtkTreePath * path)
#line 251 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::drag_data_delete"
{
#line 99 "galan-comptree-model.gob"
	
		GtkTreeIter iter;
		GtkTreeStore *store = GTK_TREE_STORE( self );

		if( ! gtk_tree_model_get_iter( GTK_TREE_MODEL(store), &iter, path ) ) {
			return FALSE;
		}
		gtk_tree_store_remove( store, &iter );
		return TRUE;
	}}
#line 266 "galan-comptree-model.c"
#undef __GOB_FUNCTION__

#line 111 "galan-comptree-model.gob"
static gboolean 
galan_comptree_model_drag_data_get (GtkTreeDragSource * self, GtkTreePath * path, GtkSelectionData * data)
#line 272 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::drag_data_get"
{
#line 111 "galan-comptree-model.gob"
	
		GtkTreeStore *store = GTK_TREE_STORE( self );
		gchar *target_name = gdk_atom_name( data->target );
		if( strcmp( target_name, "galan/CompAction" ) == 0 ) {
			GtkTreeIter iter;
			GalanCompAction *compaction;
			gboolean valid;

			if( ! gtk_tree_model_get_iter( GTK_TREE_MODEL(store), &iter, path ) ) {
				g_free( target_name );
				return FALSE;
			}
			gtk_tree_model_get( GTK_TREE_MODEL(store), &iter, 1, &valid, 2, &compaction, -1 );
			if( !valid ) {
				g_free( target_name );
				return FALSE;
			}

			gtk_selection_data_set( data, data->target, 8, (gpointer) &compaction, sizeof( GalanCompAction * ) );
			g_free( target_name );
			return TRUE;
		}
		g_free( target_name );
		return FALSE;
	}}
#line 302 "galan-comptree-model.c"
#undef __GOB_FUNCTION__

#line 138 "galan-comptree-model.gob"
static gboolean 
galan_comptree_model_drag_data_received (GtkTreeDragDest * self, GtkTreePath * path, GtkSelectionData * data)
#line 308 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::drag_data_received"
{
#line 138 "galan-comptree-model.gob"
	
		printf( "Data received...\n" );		
		GalanCompAction *cact = * ((GalanCompAction **) data->data);
		if( GALAN_IS_COMPACTION( cact ) ) {
			GtkTreeStore *store = GTK_TREE_STORE( self );
			GtkTreeIter dest, added;
			gtk_tree_model_get_iter( GTK_TREE_MODEL(store), &dest, path );
			gtk_tree_store_insert_before( store, &added, NULL, &dest );
			char *cact_label;
			g_object_get( cact, "label", &cact_label, NULL );
			gtk_tree_store_set( store, &added, 0, cact_label, 1, TRUE, 2, cact, -1 );
			g_free( cact_label );
			
			
		}

		return TRUE;
	}}
#line 331 "galan-comptree-model.c"
#undef __GOB_FUNCTION__

#line 157 "galan-comptree-model.gob"
static gboolean 
galan_comptree_model_row_drop_possible (GtkTreeDragDest * self, GtkTreePath * path, GtkSelectionData * data)
#line 337 "galan-comptree-model.c"
{
#define __GOB_FUNCTION__ "Galan:CompTree:Model::row_drop_possible"
{
#line 157 "galan-comptree-model.gob"
	
		printf( "possible ?\n" );		
		return TRUE;
	}}
#line 346 "galan-comptree-model.c"
#undef __GOB_FUNCTION__
